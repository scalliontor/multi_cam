import numpy as np
import cv2
from scipy.optimize import least_squares
from scipy.spatial.transform import Rotation as R_scipy

# The file generated by the first script
INPUT_DATA_FILE = "extrinsics.npz" 
# The final, refined output file
FINAL_OUTPUT_FILE = "extrinsics_final.npz"

# --- 1. The Cost Function for the Optimizer ---
def cost_function(params, points_pc, points_rgb):
    """
    Calculates the 3D alignment error (residuals) for a given transformation.
    The optimizer's goal is to drive the output of this function to zero.
    """
    rvec = params[:3]
    tvec = params[3:] # tvec is in meters here

    # Apply the transformation: P_rgb = R * P_pc + t
    R_matrix = R_scipy.from_rotvec(rvec).as_matrix()
    transformed_points = (R_matrix @ points_pc.T).T + tvec

    # Calculate the error for each point
    residuals = transformed_points - points_rgb
    return residuals.flatten()

# --- 2. Load the data and the initial guess ---
try:
    with np.load(INPUT_DATA_FILE) as data:
        points_pc_m = data['points_pc']
        points_rgb_m = data['points_rgb']
        initial_rvec = data['initial_rvec'].flatten()
        initial_tvec_mm = data['initial_tvec_mm'].flatten()
        initial_tvec_m = initial_tvec_mm / 1000.0 # Convert to meters
except FileNotFoundError:
    print(f"Error: Input file '{INPUT_DATA_FILE}' not found.")
    print("Please run `1_calculate_initial_extrinsics.py` first.")
    exit()

# Combine rvec and tvec into a single parameter array for the optimizer
initial_params = np.hstack([initial_rvec, initial_tvec_m])

# --- 3. Run the Optimization (Bundle Adjustment) ---
print("--- Step 2: Refining Extrinsics with Bundle Adjustment ---")
print(f"Loaded {len(points_pc_m)} 3D point pairs for refinement.")

# Calculate the initial error before optimization
initial_residuals = cost_function(initial_params, points_pc_m, points_rgb_m)
initial_rmse = np.sqrt(np.mean(initial_residuals**2)) * 1000
print(f"Initial RMSE (from SVD guess): {initial_rmse:.4f} mm")

print("\nRunning non-linear least squares optimizer (SciPy)...")
result = least_squares(
    fun=cost_function,
    x0=initial_params,
    args=(points_pc_m, points_rgb_m),
    method='trf', # Trust Region Reflective is a good general-purpose choice
    verbose=2 # Print optimization progress
)

# --- 4. Extract and Save the Refined Results ---
refined_params = result.x
refined_rvec = refined_params[:3]
refined_tvec_m = refined_params[3:]

final_residuals = result.fun
final_rmse = np.sqrt(np.mean(final_residuals**2)) * 1000
print(f"\n--- Optimization Complete ---")
print(f"Final Refined RMSE: {final_rmse:.4f} mm")

# Format for saving
refined_R = R_scipy.from_rotvec(refined_rvec).as_matrix()
refined_tvec_mm = refined_tvec_m.reshape(3, 1) * 1000

print("\nRefined Rotation Vector (rvec):\n", refined_rvec)
print("Refined Translation Vector (tvec) in mm:\n", refined_tvec_mm)

np.savez(FINAL_OUTPUT_FILE,
         rvec=refined_rvec,
         tvec=refined_tvec_mm,
         R=refined_R,
         rmse_mm=final_rmse)

print(f"\nFinal, refined extrinsics saved to '{FINAL_OUTPUT_FILE}'")